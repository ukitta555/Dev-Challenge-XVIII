# Box Cutter V8 (Alpha version)
## _DEV Challenge XVIII submission_

## 1. Шаги для запуска сервиса:
- Установить Docker & Docker-Compose.
- Выполняем docker compose up в корневой папке приложения.
- Это все! Вы молодец и заслужили мороженку.

Выполнение компанды запускает как сервис, так и тесты. Для запуска по отдельности:
- docker compose up test - тесты
- docker compose up prod - сервис

Для того, чтобы получить ответ от сервиса, отправьте POST-запрос на порт 8080.

## 2. Подход к решению задачи

Интересный факт про коробки:
1. Заметим, что раскрой коробки можно сделать по-разному. Нам все равно на порядок размеров - если поменять местами размеры w, h, d на рисунке из PDF с заданием (да и вообще на любом раскрое коробоки), то из начального и конечного раскроя получим одинаковые коробки! Доказательство данного факта простое - если готовую коробку поставить на пол другой гранью, то коробка останется той же, но ее раскрой будет другой в длину и ширину!
2. Используя этот факт, а так же то, что мы можем повернуть раскрой на 90 градусов, при этом не переходя в дробные координаты, строится наше решение, которое описано ниже.

**Алгоритм решения:**
1. Валидируем входные данные. (отрицательные числа и подобное)
2. Перебираем все возможные перестановки размеров коробки (всего 3! = 6 штук)
3. Для каждой перестановки определяем, можем ли мы сделать с такими параметрами листа раскрой в форме креста.
4. Если можем, то определяем формат раскроя - горизонтальный или вертикальный.
5. Пилим коробку...

Сложность решения - O(1) (для каждого запроса мы расчитываем пару максимумов/минимумов, а также выполняем несколько арифметических операций), значит, для N запросов получаем сложность O(N).

Чем алгоритм хорош:
- Неплохая асимптотика (хотя и решение не всегда верное, см. ниже)
- Неочевидный момент с возможностью перестановок размеров
- Относительно прост в имплементации

## 3. Future improvements
**Алгоритм решения не идеален** - в нем есть много неучтенных деталей. А именно:
1. Мы можем поместить раскрой по диагонали, при этом в форме креста аналогичный раскрой бы не поместился.  Проблема - переход в дробные координаты. Возможное решение - воспользоваться формулами для расчета длин проекций (side * cos(x) или side * sin(x) и подобные им), но на имплементацию не хватило времени :( Более того, есть шанс, что получим извечную проблему с точностью дробных чисел (получим неточный раскрой). Учитывая, что решение написано на Node.js, то без дополнительных библиотек для scientific-расчетов не обойтись. (если хотим закончить проект в адекватное время)
2. Математическая модель правильных раскроев и написания скрипта, который найдет все возможные раскрои. **Для чего нужно**: существуют раскрои, которые могут узкими и длинными, например, как тетромино S из знаменитой игры Тетрис, только по 3 блока в длину на каждом из уровней. (можете убедится, что из такого раскроя можно сделать кубическую коробку!). Это только один из примеров, но на некоторых листах этот раскрой может помочь сделать заветную коробку.
3. Используя пункт 2, по двумерному массиву, содержащий раскрой, формировать "на лету" алгоритм вырезания. В данный момент в приложении алгоритм написан в стиле hard-code (только под форму креста). Если же сгенерировать много моделей раскроя, то вручную писать алгоритм под каждую - не вариант.
4. Также были мысли по поводу решения задачи Hard. Для этого были попытки решить пункт 2 данного списка + попытка решить задачу при помощи графов, но безуспешно. Для решения рассматривались свойства соседних граней коробки и плоскостей, в которых они лежат - попытка вывести "формулу правильного раскроя". К некоторым резлуьтатам это привело,  но точного математического определения так и не получилось вывести. В момент написания данного Readme мною был найден метод раскраски, возможно он прольет свет на решение задачи. Отметим, что в общем случае задача - NP-сложная (пришлось даже мельком проглядывать научные статьи, но мне кажется, что это уже перебор для 8-часовой задачи :) ).


В будущем также можно внедрить поддержку для вырезания множества коробок(см. п. 4) и сделать пользовательский интерфейс для данного сервиса, чтобы процесс резки можно было контроллировать и останавливать при надобности.

## final notes
Прошу заметить, что это мой первый опыт работы с Docker Compose и Dockerfile, когда я редактирую его вручную и не пользуюсь полностью готовым решением, поэтому не судите строго, если там есть недочеты :) 
